#include <numeric>
#include <algorithm>
#include <cassert>
#include <vector>


#include "dominance-tests.hpp"
#include "group-skyline-concepts.hpp"
#include "listing-danisch.hpp"
#include "postprocessing.hpp"

#include "zhang19.hpp"

namespace base
{
    using Layer = int;
    using Coord = int;
    using SpatialPoint = std::vector<Coord>;
    using PointList = std::vector<SpatialPoint>;

    static_assert(std::is_same<Coord, typename myLabel::value_type>::value, "Coord type is consistent with structs.hpp");
    static_assert(std::is_same<SpatialPoint, myLabel>::value, "SpatialPoint type is consistent with structs.hpp");
    static_assert(std::is_same<PointList, myLabelVec>::value, "PointList type is consistent with structs.hpp");

    CliqueList selectSkylineCliques(CliqueList && all_cliques, PointList const& labels)
    {
        for(auto i = 0lu, n = all_cliques.size(); i < n; ++i)
        {
            if(std::any_of(std::cbegin(all_cliques), std::cend(all_cliques),
            [&labels, &clique = all_cliques[i]](auto const& comparePoint)
            {
                return GroupDominanceTest(comparePoint.cbegin(), comparePoint.cend(), clique.cbegin(), clique.cend(), labels);
            }))
            {
                std::swap(all_cliques[i], all_cliques.back());
                all_cliques.resize(--n);
                --i;
            }
        }

        return all_cliques;        
    }

    namespace zhang
    {
        /**
         * Algorithm 2 from Zhang et al. (2019). CIKM.
         * Conducts dominance check between two cliques with a series of pruning conditions.
         * Returns true if s group-dominates c; false otherwise.
         */
        bool cliqueSDominatesCliqueC(Clique const& c, Clique const& s, PointList const& labels)
        {
            myLabel const worst = GetWorstVirtualPoint(s, labels);
            myLabel const best  = GetBestVirtualPoint(s, labels);
            if(PointDominanceTest(worst.cbegin(), worst.cend(), best.cbegin()) == DominanceTestResult::dominates) { return true; }

            // reduction to common elements performed inside GroupDominanceTest() function below.
            // Bipartite matching not relevant to this group-dominance definition (too expensive).

            return GroupDominanceTest(s.cbegin(), s.cend(), c.cbegin(), c.cend(), labels);
        }

        template <typename CliqueIterator>
        bool cliqueRangeDominatesCliqueC(Clique const& c, CliqueIterator start, CliqueIterator end, PointList const& labels)
        {
            return std::any_of(start, end,
                [&c, &labels](auto const& clique_s)
                {
                    return cliqueSDominatesCliqueC(c, clique_s, labels);
                });
        }

        void copySkylineCliques(CliqueList& skylineCommunities, CliqueList && candidates, PointList const& labels)
        {
            auto const skyline_cliques = selectSkylineCliques(std::move(candidates), labels);
            std::copy(std::cbegin(skyline_cliques), std::cend(skyline_cliques), std::back_inserter(skylineCommunities));
        }

        CliqueList filterCliquesWithSkyline(CliqueList && cliques, CliqueList const& skylineCommunities, PointList const& labels)
        {
            cliques.erase(
                std::remove_if(cliques.begin(), cliques.end(),
                    [start=std::cbegin(skylineCommunities), end=std::cend(skylineCommunities), &labels](auto const& clique)
                    {
                        return cliqueRangeDominatesCliqueC(clique, start, end, labels);
                    })
                , cliques.end());

            return cliques;
        }

        auto fetchLayerBoundaries(Layer l, std::vector<Layer> const& boundaries)
            -> std::pair<Layer, Layer>
        {
            return std::make_pair(boundaries[l], boundaries[l+1]);
        }

        /**
         * Simple filter to check whether the graph contains enough vertices to possibly make
         * a clique of a given size.
         * Pruning condition on Line 5 of Algorithm 3
         */
        template <typename List>
        bool graphIsSkippable(List const& list, size_t sizeThreshold)
        {
            return (list.size() < sizeThreshold);
        }

        /**
         * Returns the intersection of the tail set and the neighbour list of cur_node.
         * Assumes that the tail set is generated by std::iota and the neighbour list is sorted ascending.
         */
        NodeList filterTailsetToAdjacent(NodeList const& neighbours, Node cur_node)
        {
            auto const new_start = std::upper_bound(neighbours.crbegin(), neighbours.crend(), cur_node);
            intVec filteredTailSet(new_start, neighbours.crend());
            return filteredTailSet;
        }


        void extractSkylineCommunitiesFromLayer(CliqueList& skylineCommunities, Layer layer, Graph const& graph, size_t cliqueSize)
        {
            auto const adjMap = adjListToMap(graph.edges);
            auto const [layer_start, layer_end] = fetchLayerBoundaries(layer, graph.skyLayersBoundaries);

            for(auto cur_node = layer_start; cur_node < layer_end; ++cur_node)
            {
                auto const tailset = filterTailsetToAdjacent(graph.edges[cur_node], cur_node);
                if(!graphIsSkippable(tailset, cliqueSize - 1))
                {
                    auto const subgraph = listing::induceSubgraph(adjMap, NodeSet(tailset.cbegin(), tailset.cend()));
                    if(!graphIsSkippable(subgraph, cliqueSize - 1))
                    {
                        auto cliquesWithThisNode = listing::getCliquesContainingNode(subgraph, cur_node, cliqueSize);
                        auto filteredCliques = filterCliquesWithSkyline(std::move(cliquesWithThisNode), skylineCommunities, graph.labels);
                        copySkylineCliques(skylineCommunities, std::move(filteredCliques), graph.labels);
                    }
                }
            } 
        }

        void updateRepresentatives(PointList & representatives, CliqueList const& cliques, PointList const& labels)
        {
            // Assumes that all cliques that are not yet in the representative list come at the end of the clique list.
            std::transform(std::cbegin(cliques) + representatives.size(), std::cend(cliques), std::back_inserter(representatives),
                [&labels](auto const& clique)
                {
                    return GetWorstVirtualPoint(clique, labels);
                });
        }


        /**
         * Algorithm 3 in Zhang et al. (CIKM 2019). "Selecting the Optimal Groups: Efficiently Computing Skyline k-Cliques"
         * Modified to exclude contributions relating to permutation-based dominance definition
         * Performs layer-based iteration strategy with early pruning by layer and node pruning by coreness
         */
        void GetSkylineCommunities(Graph& myGraph, [[maybe_unused]] int coreSize, int groupSize, CliqueList& skylineCommunities)
        {
            assert("Zhang19 can only handle cliques" && (coreSize == groupSize - 1));
            skylineCommunities.clear();
            PointList skylineRepresentatives;

            for(auto layer = 0lu, n = myGraph.skyLayersBoundaries.size(); layer < n; ++layer)
            {
                if(CanTerminate(skylineRepresentatives, myGraph.layerRepresentatives[layer]))
                {
                    // Early Termination 2: Best of layer is dominated by a point in the skyline
                    // Note: comments on implementation of Theorem 5 state that, following [BKS01],
                    // max points of each skyline clique should be indexed in an R-tree.
                    // However, this is a simple skyline lookup query and a bizarre suggestion:
                    //   - First, Section 4.2 of [BKS01] is a poor depth-first algorithm much improved
                    //     by the BBS algorithm of Papadias et al.
                    //   - Second, these algorithms are optimised for disk, but [Zha+19] is
                    //     clearly an in-memory algorithm (obvious from lack of loop tiling).
                    // As a result, [Akb22]'s finding that quad trees are better is not surprising;
                    // it is consistent with fast in-memory skyline algorithms, such as [Zha+09]'s SIGMOD OSP.
                    // TODO: Revisit this implementation of CanTerminate (and replicate [Akb22]?).
                    break;
                }
                else
                {
                    extractSkylineCommunitiesFromLayer(skylineCommunities, layer, myGraph, static_cast<size_t>(groupSize));
                    updateRepresentatives(skylineRepresentatives, skylineCommunities, myGraph.labels);
                }
            }

            // similar to remove-erase idiom; get rid of false positives
            skylineCommunities.erase( postprocess( std::begin( skylineCommunities )
                                                 , std::end( skylineCommunities )
                                                 , myGraph.labels )
                                    , std::end( skylineCommunities ) );
        }      
    } // namespace zhang



    namespace zhangBaseline
    {

        /**
         * Algorithm 1 in Zhang et al. (CIKM 2019). "Selecting the Optimal Groups: Efficiently Computing Skyline k-Cliques"
         * Simple baseline that retrieves all cliques and then runs a stupidly naive nested loop algorithm over them.
         */
        void GetSkylineCommunities(Graph& myGraph, [[maybe_unused]] int coreSize, int groupSize, CliqueList& skylineCommunities)
        {
            assert("Baselines can only handle cliques" && (coreSize == groupSize - 1));
            skylineCommunities.clear();

            auto all_cliques = listing::getAllCliques(myGraph.edges, groupSize);
            skylineCommunities = selectSkylineCliques(std::move(all_cliques), myGraph.labels);
        }
    } // namespace zhangBaseline
} // namespace base
